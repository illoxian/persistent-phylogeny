/** 
 * 
 * @file main.cpp
 * 
 * @author Simone Paolo Mottadelli
 * 
 */

#include <boost/program_options.hpp>
#include "rbgraph.hpp"
#include "functions.hpp"

int main(int argc, const char* argv[]) {
 // declare the vector of input files
  std::vector<std::string> files;

  // initialize options menu
  boost::program_options::options_description general_options(
      "Usage: ppp [OPTION...] FILE..."
      "\n\n"
      "Compute the PPP algorithm on the matrices in input. Note that the algorithm will be executed on the maximal reducible graphs generated from the input matrices."
      "\n\n"
      "Options");

  general_options.add_options()
      // option: help message
      ("help,h", "Display this message.\n")
      // option: verbose, print information on the ongoing operations
      ("verbose,v", boost::program_options::bool_switch(&logging::enabled),
       "Display the operations performed by the program.\n")
      // option: testpy, test reduce output with a python script

      // option: test ppr-general algorithm
      ("ppralgorithm,ppr", "???");

  // initialize hidden options (not shown in --help)
  boost::program_options::options_description hidden_options;
  // option: input files
  hidden_options.add_options()(
      "files", boost::program_options::value<std::vector<std::string>>(&files));

  // initialize positional options
  boost::program_options::positional_options_description positional_options;
  // add input files to the positional options
  positional_options.add("files", -1);

  // initialize options
  boost::program_options::options_description cmdline_options;
  // add the options menu and the hidden options to the available options
  cmdline_options.add(general_options).add(hidden_options);

  // initialize the variables map
  boost::program_options::variables_map vm;

  try {
    // parse the options given in input, and check them against positional and
    // cmdline options: store the result in vm
    boost::program_options::store(
        boost::program_options::command_line_parser(argc, argv)
            .positional(positional_options)
            .options(cmdline_options)
            .run(),
        vm);

    boost::program_options::notify(vm);
  } catch (const std::exception& e) {
    // error while parsing the options given in input
    std::cerr << "Error: " << e.what() << "." << std::endl
              << "Try '" << argv[0] << " --help' for more information."
              << std::endl;

    return 1;
  }

  if (vm.count("help")) {
    // help option specified
    std::cerr << general_options << std::endl;

    return 1;
  }

  if (!vm.count("files")) {
    // no input files specified
    std::cerr << "Error: No input file specified." << std::endl
              << "Try '" << argv[0] << " --help' for more information."
              << std::endl;

    return 1;
  }

  std::cout << "\n[INFO] This program executes the PPP algorithm on the matrices specified in input. Please note that the algorithm will be executed on the maximal reducible graphs generated from the input matrices. Future extensions of the program will allow to process general graphs too." << std::endl;

  std::cout << "[INFO] Starting..." << std::endl;
  if (files.size() > 1) {
    std::cout << "[INFO] Running PPP on " << files.size() << " files." << std::endl;
  }

  size_t count_file = 0;
  for (const auto& file : files) {

    count_file++;

    std::cout << "[INFO] Processing  \"" << file << "\"..." << std::endl;

    if (logging::enabled) {
      // verbosity enabled
      std::cout << "Reading the matrix from the file..." << std::endl;
    }

    RBGraph g;

    try {
      read_graph(file, g);
    } catch(std::runtime_error e) {
      std::cout << e.what() << std::endl;
      exit(0);
    }

    if (logging::enabled) {
      // verbosity enabled
      std::cout << "[INFO] Extracting the maximal reducible graph..."  << std::endl;
    }

    RBGraph gm;
    maximal_reducible_graph(g, gm, false);

    if (logging::enabled) {
      // verbosity enabled
      std::cout << "[INFO] Executing the PPP algorithm on the extracted maximal reducible graph..." << std::endl;
    }

    bool successfully_reduced = false;
    std::list<SignedCharacter> realized_characters;

    try {
      realized_characters = ppp_maximal_reducible_graphs(gm);
      successfully_reduced = true;
    } catch(...) {
      successfully_reduced = false;
    }

    if (!successfully_reduced) {
      std::cout << "[WARNING] The graph can not be reduced!" << std::endl;
    } else {
      std::cout << "[OK] The graph has been successfully reduced! The realized characters are: ";
      std::cout << "<";
      for (SignedCharacter sc : realized_characters)
        std::cout << "(" << sc << ") ";
      std::cout << ">" << std::endl;
    }

    std::cout << "[INFO] Processing  \"" << file << "\"... DONE!\n" << std::endl;
  }

  std::cout << "[INFO] Finished processing the input files. Terminated successfully." << std::endl;

  return 0;
}


void compute_gskeleton(const RBGraph &g, RBGraph &g_skeleton) {
    RBGraph g_min;
    minimal_form_graph(g, g_min);
    maximal_reducible_graph(g_min, g_skeleton, true);
}

// void source_2_solvable(RBGraph &g) {
    
// }


// std::list<SignedCharacter> source_2_solvable(RBGraph &g)
// {
//   RBGraph gmax, gmin;

//   // compute gm g-skeleton of g
//   int source_size = get_sources(g).size();

//   if (source_size == 1)
//   {
//     std::list<SignedCharacter> extension;
//     RBVertex ext;
//     ext = get_extension(*get_sources(g).begin(), gmax, gmin);

//     if (extension.size() == 1)
//       return extension;
//   }
//   if (source_size == 2)
//   {
//     std::list<SignedCharacter> source1, source2;
//     //assign respective extensions


//   }
//   std::list<SignedCharacter> null_ret;
//   return  null_ret; // returning an empty set if either of the 2if statement is taken
// }

// // void test_l_source(std::list<SignedCharacter> source) {
// //   maximal_characters()
// // }
// bool is_3_canonical(std::list<)

std::list<SignedCharacter> source_2_solvable(const RBGraph &g) {
  RBGraph g_skeleton;
  compute_gskeleton(g, g_skeleton);


  if (get_sources(g).size() == 1) {

  }

  else if (get_sources(g).size() == 2) {

  }

  else {
    std::list<SignedCharacter> emptyret;
    return emptyret;
  }
}

std::list<SignedCharacter> ppr_general(RBGraph &g, std::list<SignedCharacter> a) {

    std::list<SignedCharacter> realized_chars = realize_red_univ_and_univ_chars(g).first;
    remove_duplicate_species(g);
    std::list<SignedCharacter> tmp;


    while (!is_empty(g)) {

        RBGraph g_skeleton;  
        compute_gskeleton(g, g_skeleton);
        std::list<RBVertex> sources = get_sources(g_skeleton);

        if(is_2_solvable(sources, g_skeleton)) {
            //tmp = source_2_solvable(g, );
            tmp = source_2_solvable(g_skeleton);
        }
        // else if(is_3_canonical(g_maximal))
        // else if(is_m_solvable(g_maximal)) {}

        // if tmp is not empty 
        if (! tmp.empty()) {
            //prendo il primo carattere e lo realizzo (unico carattere, maybe tmp non e' una lista)
            realize_character(*tmp.begin(), g);
            
            realized_chars.splice(realized_chars.end(), tmp);
            realized_chars.splice(realized_chars.end(), realize_character(*tmp.begin(), g).first);
            remove_duplicate_species(g);

        

        // iterates over connected components
          RBGraphVector conn_comp = connected_components(g);
          auto cc = conn_comp.begin();
          auto cc_end = conn_comp.end();
          for (; cc != cc_end; ++cc)
          { //itera sulle componenti connesse
            RBGraph tmp_graph;
            copy_graph(*cc->get(), tmp_graph);
            tmp = ppr_general(*cc->get());
            for (RBVertex v : tmp_graph.m_vertices)
              remove_vertex(tmp_graph[v].name, g);
            realized_chars.splice(realized_chars.end(), tmp);
          }
        }
    }
    return realized_chars;
}

// std::list<SignedCharacter> ppr_general(RBGraph &g, std::list<SignedCharacter> a) {
//   std::list<SignedCharacter> realized_chars = realize_red_univ_and_univ_chars(g).first; // A == realized chars, as in algorithm 2
//                                                                                           // A set of characters in r == realized_chars of g
//   remove_duplicate_species(g);
//   // r temporary std::list
//   std::list<SignedCharacter> tmp;
//   // sources
//   while (!is_empty(g))
//   {
//     // Computed G-Skeleton

//     RBGraph g_skeleton = compute_gskeleton(g);
//     // is_2_solvable( *get_sources(g_skeleton).begin(), g_skeleton);

//     source_2_solvable(g_skeleton);

    
//     // if Gm is 2-solvable
//     // then r:= Source-2solvable(G,A)

//     if (true) //!r.empty()
//     {
//       // realize r==tmp in G
//       realized_chars.splice(realized_chars.end(), tmp);
//       realized_chars.splice(realized_chars.end(), realize_red_univ_and_univ_chars(g).first);
//       remove_duplicate_species(g);
//       // ? update A with r?
//       realized_chars = tmp;
//       // (update G, A)

//       // iterates over connected components
//       RBGraphVector conn_comp = connected_components(g);
//       auto cc = conn_comp.begin();
//       auto cc_end = conn_comp.end();
//       for (; cc != cc_end; ++cc)
//       { //itera sulle componenti connesse
//         RBGraph tmp_graph;
//         copy_graph(*cc->get(), tmp_graph);
//         tmp = ppr_general(*cc->get());
//         for (RBVertex v : tmp_graph.m_vertices)
//           remove_vertex(tmp_graph[v].name, g);
//         realized_chars.splice(realized_chars.end(), tmp);
//       }
//     }
//     // return realized_chars;
//     return tmp;
//   }
//   return tmp;
// }

